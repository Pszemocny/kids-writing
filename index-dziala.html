<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aplikacja Text-to-Speech z Kolorami</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
            display: flex;
            flex-direction: column;
            height: 100vh;
            gap: 20px;
        }

        /* Sekcja tekstowa */
        .text-section {
            flex: 1;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
        }

        .text-input {
            width: 100%;
            height: 100%;
            border: none;
            outline: none;
            font-size: 24px;
            line-height: 1.5;
            resize: none;
            background: transparent;
            color: #333;
            font-family: inherit;
        }

        .text-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            align-items: center;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: #4CAF50;
            color: white;
        }

        .btn-primary:hover {
            background: #45a049;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #f44336;
            color: white;
        }

        .btn-secondary:hover {
            background: #da190b;
            transform: translateY(-2px);
        }

        /* Sekcja kolor√≥w */
        .color-section {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .color-section h3 {
            text-align: center;
            margin-bottom: 20px;
            color: #333;
            font-size: 18px;
        }

        .color-palettes {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .palette {
            background: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
        }

        .palette:hover {
            transform: translateY(-5px);
        }

        .palette-name {
            text-align: center;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }

        .palette-colors {
            display: flex;
            gap: 5px;
            justify-content: center;
        }


        .color-dot {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s ease;
        }

        .color-dot:hover {
            transform: scale(1.2);
            border-color: #333;
        }

        .color-dot.selected {
            border-color: #333;
            transform: scale(1.1);
        }

        /* Sekcja klawiatury */
        .keyboard-section {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .keyboard {
            display: grid;
            gap: 5px;
            max-width: 800px;
            margin: 0 auto;
        }

        .keyboard-row {
            display: flex;
            gap: 5px;
            justify-content: center;
        }

        .key {
            min-width: 45px;
            height: 45px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(145deg, #f0f0f0, #d0d0d0);
            box-shadow: 3px 3px 6px #bebebe, -3px -3px 6px #ffffff;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .key:hover {
            background: linear-gradient(145deg, #e0e0e0, #c0c0c0);
        }

        .key:active {
            box-shadow: inset 2px 2px 4px #bebebe, inset -2px -2px 4px #ffffff;
            transform: translateY(1px);
        }

        .key.space {
            min-width: 200px;
        }

        .key.special {
            min-width: 70px;
            font-size: 12px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
                gap: 15px;
            }

            .text-input {
                font-size: 18px;
            }

            .color-palettes {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            }

            .key {
                min-width: 35px;
                height: 35px;
                font-size: 14px;
            }

            .key.space {
                min-width: 150px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Sekcja tekstowa -->
        <div class="text-section">
            <div class="text-controls">
                <button class="btn btn-primary" id="playBtn">‚ñ∂ Odczytaj tekst</button>
                <button class="btn btn-secondary" id="stopBtn">‚èπ Stop</button>
                <button class="btn btn-primary" id="clearBtn">üóë Wyczy≈õƒá</button>
                <button class="btn btn-primary" id="testBtn">üîä Test g≈Çosu</button>
                <label>
                    Prƒôdko≈õƒá:
                    <input type="range" id="speedRange" min="0.5" max="2" step="0.1" value="1">
                    <span id="speedValue">1.0</span>
                </label>
            </div>
            <textarea class="text-input" id="textInput" placeholder="Zacznij pisaƒá... Litery bƒôdƒÖ czytane na bie≈ºƒÖco, a s≈Çowa po zako≈Ñczeniu pisania."></textarea>
        </div>

        <!-- Sekcja kolor√≥w -->
        <div class="color-section">
            <h3>Wybierz paletƒô kolor√≥w</h3>
            <div class="color-palettes" id="colorPalettes">
                <!-- Palety bƒôdƒÖ generowane przez JavaScript -->
            </div>
        </div>

        <!-- Sekcja klawiatury -->
        <div class="keyboard-section">
            <div class="keyboard" id="keyboard">
                <div class="keyboard-row">
                    <button class="key">1</button>
                    <button class="key">2</button>
                    <button class="key">3</button>
                    <button class="key">4</button>
                    <button class="key">5</button>
                    <button class="key">6</button>
                    <button class="key">7</button>
                    <button class="key">8</button>
                    <button class="key">9</button>
                    <button class="key">0</button>
                    <button class="key special" data-key="Backspace">‚å´</button>
                </div>
                <div class="keyboard-row">
                    <button class="key">q</button>
                    <button class="key">w</button>
                    <button class="key">e</button>
                    <button class="key">r</button>
                    <button class="key">t</button>
                    <button class="key">y</button>
                    <button class="key">u</button>
                    <button class="key">i</button>
                    <button class="key">o</button>
                    <button class="key">p</button>
                </div>
                <div class="keyboard-row">
                    <button class="key">a</button>
                    <button class="key">s</button>
                    <button class="key">d</button>
                    <button class="key">f</button>
                    <button class="key">g</button>
                    <button class="key">h</button>
                    <button class="key">j</button>
                    <button class="key">k</button>
                    <button class="key">l</button>
                    <button class="key">ƒÖ</button>
                </div>
                <div class="keyboard-row">
                    <button class="key">z</button>
                    <button class="key">x</button>
                    <button class="key">c</button>
                    <button class="key">v</button>
                    <button class="key">b</button>
                    <button class="key">n</button>
                    <button class="key">m</button>
                    <button class="key">ƒô</button>
                    <button class="key">ƒá</button>
                    <button class="key">≈Ñ</button>
                </div>
                <div class="keyboard-row">
                    <button class="key">≈õ</button>
                    <button class="key">√≥</button>
                    <button class="key">≈Ç</button>
                    <button class="key">≈º</button>
                    <button class="key">≈∫</button>
                    <button class="key space" data-key=" ">Spacja</button>
                    <button class="key">.</button>
                    <button class="key">,</button>
                    <button class="key">!</button>
                    <button class="key">?</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        class TextToSpeechApp {
            constructor() {
                console.log('üé§ Inicjalizacja aplikacji TTS...');
                this.textInput = document.getElementById('textInput');
                this.playBtn = document.getElementById('playBtn');
                this.stopBtn = document.getElementById('stopBtn');
                this.clearBtn = document.getElementById('clearBtn');
                this.testBtn = document.getElementById('testBtn');
                this.speedRange = document.getElementById('speedRange');
                this.speedValue = document.getElementById('speedValue');
                this.keyboard = document.getElementById('keyboard');
                this.colorPalettes = document.getElementById('colorPalettes');

                this.synth = window.speechSynthesis;
                this.currentUtterance = null;
                this.typingTimer = null;
                this.speechTimeout = null;
                this.lastWordSpoken = '';

                console.log('üé§ Sprawdzanie dostƒôpno≈õci Speech Synthesis API:', !!this.synth);
                this.checkVoices();
                this.init();
            }

            init() {
                console.log('üé§ Uruchamianie aplikacji...');
                this.setupEventListeners();
                this.createColorPalettes();
                this.loadSavedSettings();
                console.log('‚úÖ Aplikacja gotowa');
            }

            checkVoices() {
                const voices = this.synth.getVoices();
                console.log('üé§ Dostƒôpne g≈Çosy:', voices.length);

                if (voices.length === 0) {
                    console.log('‚è≥ G≈Çosy jeszcze siƒô ≈ÇadujƒÖ, czekam...');
                    // W Chrome/Brave g≈Çosy ≈ÇadujƒÖ siƒô asynchronicznie
                    this.synth.addEventListener('voiceschanged', () => {
                        this.checkVoicesAgain();
                    });
                    return;
                }

                this.analyzeVoices(voices);
            }

            checkVoicesAgain() {
                console.log('üîÑ Sprawdzam g≈Çosy ponownie...');
                const voices = this.synth.getVoices();
                this.analyzeVoices(voices);
            }

            analyzeVoices(voices) {
                console.log('üé§ Dostƒôpne g≈Çosy:', voices.length);
                const polishVoices = voices.filter(voice => voice.lang.startsWith('pl'));
                const anyVoices = voices.length > 0;

                console.log('üáµüá± Polskie g≈Çosy:', polishVoices.length, polishVoices.map(v => v.name));
                console.log('üåç Wszystkie g≈Çosy:', voices.slice(0, 5).map(v => `${v.name} (${v.lang})`));

                if (polishVoices.length === 0 && anyVoices) {
                    console.warn('‚ö†Ô∏è Brak polskich g≈Ços√≥w! U≈ºywam domy≈õlnego g≈Çosu.');
                } else if (voices.length === 0) {
                    console.error('‚ùå Brak jakichkolwiek g≈Ços√≥w w systemie!');
                }
            }

            setupEventListeners() {
                // Text input events
                this.textInput.addEventListener('input', (e) => this.handleTextInput(e));

                // Control buttons
                this.playBtn.addEventListener('click', () => this.readFullText());
                this.stopBtn.addEventListener('click', () => this.stopSpeech());
                this.clearBtn.addEventListener('click', () => this.clearText());
                this.testBtn.addEventListener('click', () => this.testVoice());

                // Speed control
                this.speedRange.addEventListener('input', (e) => {
                    this.speedValue.textContent = e.target.value;
                });

                // Virtual keyboard
                this.keyboard.addEventListener('click', (e) => {
                    if (e.target.classList.contains('key')) {
                        this.handleKeyPress(e.target);
                    }
                });

                // Color palette selection
                this.colorPalettes.addEventListener('click', (e) => {
                    if (e.target.classList.contains('color-dot')) {
                        this.selectColor(e.target);
                    }
                });
            }

            handleTextInput(e) {
                const input = e.target;
                const text = input.value;
                const lastChar = text.slice(-1);

                console.log('‚å®Ô∏è Input event:', {
                    inputType: e.inputType,
                    lastChar: lastChar,
                    textLength: text.length
                });

                // Sprawd≈∫ czy to nie jest przypadkowe wyczyszczenie przez API
                if (e.inputType === 'deleteContentBackward' && text.length === 0 && this.synth.speaking) {
                    console.log('‚ö†Ô∏è API wyczy≈õci≈Ço tekst - przywracam...');
                    // Nie pozwalaj API na wyczyszczenie tekstu
                    return;
                }

                // Czytaj literƒô je≈õli zosta≈Ça dodana
                if (e.inputType === 'insertText' && lastChar && lastChar !== ' ') {
                    console.log('üî§ Czytam literƒô:', lastChar);
                    this.speakText(lastChar);
                }

                // Ustaw timer dla s≈Çowa
                clearTimeout(this.typingTimer);
                this.typingTimer = setTimeout(() => {
                    console.log('‚è∞ Timer s≈Çowa - sprawdzam kompletne s≈Çowo');
                    this.handleWordComplete(text);
                }, 1000);
            }

            handleWordComplete(text) {
                const words = text.trim().split(/\s+/);
                const lastWord = words[words.length - 1];

                console.log('üìù Sprawdzam s≈Çowo:', {
                    lastWord: lastWord,
                    lastWordSpoken: this.lastWordSpoken,
                    wordLength: lastWord?.length
                });

                // Ogranicz d≈Çugo≈õƒá s≈Çowa ≈ºeby uniknƒÖƒá zawieszenia API
                if (lastWord && lastWord !== this.lastWordSpoken && lastWord.length > 1) {
                    if (lastWord.length > 15) {
                        console.log('‚ö†Ô∏è S≈Çowo za d≈Çugie, skracam do 15 znak√≥w');
                        const shortWord = lastWord.substring(0, 15);
                        console.log('üìñ Czytam skr√≥conƒÖ wersjƒô:', shortWord);
                        this.speakText(shortWord);
                    } else {
                        console.log('üìñ Czytam s≈Çowo:', lastWord);
                        this.speakText(lastWord);
                    }
                    this.lastWordSpoken = lastWord;
                } else {
                    console.log('‚è≠Ô∏è Pomijam s≈Çowo (za kr√≥tkie lub ju≈º czytane)');
                }
            }

            speakText(text) {
                console.log('üé§ Pr√≥ba czytania:', text);

                if (!this.synth) {
                    console.error('‚ùå Speech Synthesis API niedostƒôpne!');
                    return;
                }

                const voices = this.synth.getVoices();
                if (voices.length === 0) {
                    console.warn('‚ö†Ô∏è Brak g≈Ços√≥w - pomijam czytanie');
                    return;
                }

                if (this.synth.speaking) {
                    console.log('‚èπÔ∏è Przerywam poprzednie czytanie');
                    this.synth.cancel();
                    // Kr√≥tka pauza po cancel()
                    setTimeout(() => this.performSpeak(text), 50);
                    return;
                }

                this.performSpeak(text);
            }

            performSpeak(text) {
                const utterance = new SpeechSynthesisUtterance(text);
                const voices = this.synth.getVoices();

                // Znajd≈∫ polski g≈Ços lub u≈ºyj domy≈õlnego
                const polishVoice = voices.find(voice => voice.lang.startsWith('pl'));
                if (polishVoice) {
                    utterance.voice = polishVoice;
                    utterance.lang = polishVoice.lang;
                    console.log('üáµüá± U≈ºywam polskiego g≈Çosu:', polishVoice.name);
                } else {
                    utterance.lang = 'pl-PL'; // Fallback
                    console.log('üåç U≈ºywam domy≈õlnego g≈Çosu z lang=pl-PL');
                }

                utterance.rate = parseFloat(this.speedRange.value);
                utterance.volume = 1.0;

                console.log('üé§ Ustawienia utterance:', {
                    text: utterance.text,
                    voice: utterance.voice?.name || 'default',
                    lang: utterance.lang,
                    rate: utterance.rate,
                    volume: utterance.volume
                });

                utterance.onstart = () => {
                    console.log('‚ñ∂Ô∏è Rozpoczƒôto czytanie:', text);
                    // Ustaw timeout - anuluj po 10 sekundach
                    this.speechTimeout = setTimeout(() => {
                        console.log('‚è∞ Timeout - anulowanie d≈Çugiego czytania');
                        this.synth.cancel();
                    }, 10000);
                };

                utterance.onend = () => {
                    console.log('‚úÖ Zako≈Ñczono czytanie:', text);
                    clearTimeout(this.speechTimeout);
                };

                utterance.onerror = (event) => {
                    console.error('‚ùå B≈ÇƒÖd TTS:', event.error, event);
                    clearTimeout(this.speechTimeout);

                    if (event.error === 'canceled') {
                        console.log('‚ÑπÔ∏è Czytanie zosta≈Ço anulowane (normalnie przy szybkim pisaniu)');
                    } else if (event.error === 'interrupted' || event.error === 'network') {
                        console.warn('‚ö†Ô∏è API siƒô zaciƒô≈Ço, pr√≥bujƒô restart...');
                        setTimeout(() => {
                            this.restartSpeechAPI();
                        }, 500);
                    }
                };

                try {
                    this.synth.speak(utterance);
                    console.log('üé§ Wywo≈Çano synth.speak()');
                } catch (error) {
                    console.error('‚ùå WyjƒÖtek podczas speak():', error);
                }
            }

            readFullText() {
                console.log('üìñ Przycisk Odczytaj - zatrzymujƒô automatyczne czytanie');
                clearTimeout(this.typingTimer);

                const text = this.textInput.value.trim();
                if (text) {
                    console.log('üìñ Czytam ca≈Çy tekst z przycisku:', text);
                    // Zatrzymaj wszystko i zr√≥b pauzƒô
                    this.synth.cancel();
                    setTimeout(() => {
                        this.performSpeak(text);
                    }, 100);
                }
            }

            testVoice() {
                console.log('üîä Test g≈Çosu');
                clearTimeout(this.typingTimer);
                this.synth.cancel();
                setTimeout(() => {
                    this.performSpeak('Test g≈Çosu Zosia');
                }, 100);
            }

            stopSpeech() {
                console.log('‚èπÔ∏è Zatrzymywanie mowy');
                clearTimeout(this.speechTimeout);
                this.synth.cancel();
            }

            restartSpeechAPI() {
                console.log('üîÑ Restart Speech API...');

                try {
                    // For≈õ anulowanie wszystkiego
                    this.synth.cancel();

                    // Wyczy≈õƒá kolejkƒô (hack dla Chrome/Brave)
                    this.synth.speak(new SpeechSynthesisUtterance(''));
                    this.synth.cancel();

                    // Kr√≥tka pauza przed sprawdzeniem
                    setTimeout(() => {
                        console.log('‚úÖ Speech API zrestartowane');
                        this.checkVoicesAgain();
                    }, 200);

                } catch (error) {
                    console.error('‚ùå B≈ÇƒÖd podczas restartu API:', error);
                }
            }

            clearText() {
                console.log('üóëÔ∏è Czyszczenie tekstu i restart API');

                // Wyczy≈õƒá tekst
                this.textInput.value = '';
                this.lastWordSpoken = '';

                // Zatrzymaj wszystkie timery
                clearTimeout(this.typingTimer);
                clearTimeout(this.speechTimeout);

                // Restart Speech API
                this.restartSpeechAPI();

                this.textInput.focus();
            }

            handleKeyPress(keyElement) {
                const key = keyElement.dataset.key || keyElement.textContent;
                const input = this.textInput;

                console.log('üéπ Klikniƒôto klawisz:', key);

                if (key === 'Backspace' || keyElement.textContent === '‚å´') {
                    const start = input.selectionStart;
                    const end = input.selectionEnd;

                    if (start === end && start > 0) {
                        input.value = input.value.slice(0, start - 1) + input.value.slice(start);
                        input.setSelectionRange(start - 1, start - 1);
                    }
                } else if (key === ' ' || keyElement.textContent === 'Spacja') {
                    this.insertTextAtCursor(' ');
                } else {
                    this.insertTextAtCursor(key);
                    if (key !== ' ') {
                        console.log('üéπ Czytam klawisz:', key);
                        this.speakText(key);
                    }
                }

                input.focus();
                input.dispatchEvent(new Event('input'));
            }

            insertTextAtCursor(text) {
                const input = this.textInput;
                const start = input.selectionStart;
                const end = input.selectionEnd;

                input.value = input.value.slice(0, start) + text + input.value.slice(end);
                input.setSelectionRange(start + text.length, start + text.length);
            }

            createColorPalettes() {
                const basePalettes = [
                    {
                        name: 'Adobe Red',
                        colors: ['#FF0000', '#CC0000', '#990000', '#660000', '#FF6666']
                    },
                    {
                        name: 'Creative Blue',
                        colors: ['#0066CC', '#004499', '#002266', '#6699FF', '#99CCFF']
                    },
                    {
                        name: 'Illustrator Purple',
                        colors: ['#6600CC', '#4D0099', '#330066', '#9966FF', '#CC99FF']
                    },
                    {
                        name: 'Photoshop Cyan',
                        colors: ['#00CCFF', '#0099CC', '#006699', '#66DDFF', '#99EEFF']
                    },
                    {
                        name: 'InDesign Magenta',
                        colors: ['#FF0099', '#CC0066', '#990033', '#FF66CC', '#FF99DD']
                    },
                    {
                        name: 'After Effects Orange',
                        colors: ['#FF6600', '#CC3300', '#993300', '#FF9966', '#FFCC99']
                    },
                    {
                        name: 'Premiere Green',
                        colors: ['#00CC66', '#009933', '#006600', '#66FF99', '#99FFCC']
                    },
                    {
                        name: 'XD Pink',
                        colors: ['#FF3399', '#CC0066', '#990033', '#FF99CC', '#FFCCDD']
                    }
                ];

                // Wyczy≈õƒá poprzednie palety
                this.colorPalettes.innerHTML = '';

                // Dodaj paletƒô nasycenia jako pierwszƒÖ (je≈õli jest wybrany kolor)
                const selectedColor = localStorage.getItem('selectedColor');
                if (selectedColor) {
                    const saturationPalette = this.createSaturationPalette(selectedColor);
                    if (saturationPalette) {
                        this.renderPalette(saturationPalette, true);
                    }
                }

                // Dodaj pozosta≈Çe palety
                const palettes = basePalettes;

                palettes.forEach(palette => {
                    this.renderPalette(palette, false);
                });
            }

            renderPalette(palette, isSaturationPalette = false) {
                const paletteDiv = document.createElement('div');
                paletteDiv.className = 'palette';
                if (isSaturationPalette) {
                    paletteDiv.classList.add('saturation-palette');
                }

                const nameDiv = document.createElement('div');
                nameDiv.className = 'palette-name';
                nameDiv.textContent = palette.name;

                const colorsDiv = document.createElement('div');
                colorsDiv.className = 'palette-colors';

                palette.colors.forEach(color => {
                    const colorDot = document.createElement('div');
                    colorDot.className = 'color-dot';
                    colorDot.style.backgroundColor = color;
                    colorDot.dataset.color = color;
                    if (isSaturationPalette) {
                        colorDot.classList.add('saturation-color');
                    }
                    colorsDiv.appendChild(colorDot);
                });

                paletteDiv.appendChild(nameDiv);
                paletteDiv.appendChild(colorsDiv);
                this.colorPalettes.appendChild(paletteDiv);
            }

            selectColor(colorDot) {
                // Usu≈Ñ poprzednie zaznaczenia
                document.querySelectorAll('.color-dot.selected').forEach(dot => {
                    dot.classList.remove('selected');
                });

                // Zaznacz wybrany kolor
                colorDot.classList.add('selected');

                // Zastosuj kolor do t≈Ça aplikacji
                const color = colorDot.dataset.color;
                this.applyColorTheme(color);

                // Je≈õli to nie jest kolor z palety nasycenia, utw√≥rz nowƒÖ paletƒô nasycenia
                if (!colorDot.classList.contains('saturation-color')) {
                    this.updateSaturationPalette(color);
                }

                // Zapisz wyb√≥r
                localStorage.setItem('selectedColor', color);
            }

            updateSaturationPalette(baseColor) {
                // Usu≈Ñ poprzedniƒÖ paletƒô nasycenia
                const existingSaturationPalette = document.querySelector('.saturation-palette');
                if (existingSaturationPalette) {
                    existingSaturationPalette.remove();
                }

                // Utw√≥rz nowƒÖ paletƒô nasycenia
                const saturationPalette = this.createSaturationPalette(baseColor);
                if (saturationPalette) {
                    // Dodaj na poczƒÖtku
                    this.renderPaletteAtBeginning(saturationPalette, true);
                }
            }

            renderPaletteAtBeginning(palette, isSaturationPalette = false) {
                const paletteDiv = document.createElement('div');
                paletteDiv.className = 'palette';
                if (isSaturationPalette) {
                    paletteDiv.classList.add('saturation-palette');
                }

                const nameDiv = document.createElement('div');
                nameDiv.className = 'palette-name';
                nameDiv.textContent = palette.name;

                const colorsDiv = document.createElement('div');
                colorsDiv.className = 'palette-colors';

                palette.colors.forEach(color => {
                    const colorDot = document.createElement('div');
                    colorDot.className = 'color-dot';
                    colorDot.style.backgroundColor = color;
                    colorDot.dataset.color = color;
                    if (isSaturationPalette) {
                        colorDot.classList.add('saturation-color');
                    }
                    colorsDiv.appendChild(colorDot);
                });

                paletteDiv.appendChild(nameDiv);
                paletteDiv.appendChild(colorsDiv);

                // Dodaj na poczƒÖtku
                this.colorPalettes.insertBefore(paletteDiv, this.colorPalettes.firstChild);
            }

            applyColorTheme(color) {
                const textInput = document.getElementById('textInput');
                textInput.style.color = color;
            }

            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            }

            createSaturationPalette(baseColor) {
                // Konwertuj hex na HSL
                const hsl = this.hexToHsl(baseColor);
                if (!hsl) return null;

                // Generuj r√≥≈ºne nasycenia (od 20% do 100%)
                const saturations = [20, 40, 60, 80, 100];
                const colors = saturations.map(saturation =>
                    this.hslToHex(hsl.h, saturation, hsl.l)
                );

                return {
                    name: 'Nasycenie',
                    colors: colors
                };
            }

            hexToHsl(hex) {
                const r = parseInt(hex.slice(1, 3), 16) / 255;
                const g = parseInt(hex.slice(3, 5), 16) / 255;
                const b = parseInt(hex.slice(5, 7), 16) / 255;

                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;

                if (max === min) {
                    h = s = 0;
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h /= 6;
                }

                return { h: h * 360, s: s * 100, l: l * 100 };
            }

            hslToHex(h, s, l) {
                l /= 100;
                const a = s * Math.min(l, 1 - l) / 100;
                const f = n => {
                    const k = (n + h / 30) % 12;
                    const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                    return Math.round(255 * color).toString(16).padStart(2, '0');
                };
                return `#${f(0)}${f(8)}${f(4)}`;
            }

            loadSavedSettings() {
                const savedColor = localStorage.getItem('selectedColor');
                if (savedColor) {
                    const colorDot = document.querySelector(`[data-color="${savedColor}"]`);
                    if (colorDot) {
                        this.selectColor(colorDot);
                    }
                }

                const savedSpeed = localStorage.getItem('speechSpeed');
                if (savedSpeed) {
                    this.speedRange.value = savedSpeed;
                    this.speedValue.textContent = savedSpeed;
                }
            }
        }

        // Inicjalizuj aplikacjƒô po za≈Çadowaniu strony
        document.addEventListener('DOMContentLoaded', () => {
            new TextToSpeechApp();
        });
    </script>
</body>
</html>